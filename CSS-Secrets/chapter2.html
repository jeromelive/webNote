<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>背景与边框</title>
	<link rel="stylesheet" type="text/css" href="./css/main.css" />
</head>
<body>
	<article class="background-border">
		<section>
			<header>
				<h1><span>1</span>半透明边框</h1>
			</header>
			<div class="entry translucent">
				<p>背景知识</p>
				<p>RGBA/HSLA颜色</p>
				<p>如果将框架div元素的背景颜色设置为white，边框不可看见</p>
				<p>默认情况下背景会延伸到边框所在的区域下层</p>
				<p>可以通过background-clip属性来调整上述默认行为带来的不变</p>
				<ul>
					<li><p>border-box:默认值，背景绘制在边框方框内</p></li>
					<li><p>padding-box:背景绘制在衬距方框内</p></li>
					<li><p>content-box:背景绘制在内容边框内</p></li>
				</ul>
			</div>
		</section>

		<section>
			<header>
				<h1><span>2</span>多重边框</h1>
			</header>
			<div class="entry multiple-borders">
				<p>背景知识</p>
				<p>box-shadow的基本用法</p>
				<p>box-shadow: h-shadow v-shadow blur spread color inset;</p>
				<p>box-shadow支持逗号分隔语法，可以创建任意数量的投影</p>
				<p>box-shadow是层层叠加的,第一层投影位于最顶层，依次类推</p>
				<p>注意</p>
				<ul>
					<li><p>投影的因为跟边框不完全一致，因为他不会影响布局，而且也不会受box-sizing属性的影响。可以用通过内边距或外边距（这个屈居于投影是内嵌还是外扩的）来额外模拟出边框需要占据的控件</p></li>
					<li><p>不影响鼠标事件，计入悬停或点击。可以给box-shadow属性加上inset关键字，使投影绘制在元素的内圈，此时需要添加额外得内边距来腾出足够的空隙。<p></li>
				</ul>
				<h2 class="additional">outline方案</h2>
				<p>如果只需要两层边框，可以使用一层常规边框，再加上outline属性来产生外层的边框。</p>
				<p>使用outline-offset属性控制它跟元素边缘之间的间距，接受复制</p>
				<p>优点：box-shadow只能模拟实线边框，outline可以产生虚线边框</p>
				<ul class="outline">
					<p>缺点</p>
					<li><span>outline不能接受用逗号分隔的多个值</span></li>
					<li><span>边框比一定会贴合border-radius属性产生的圆角</span></li>
					<li><span>兼容性欠佳</span></li>
				</ul>
			</div>
		</section>

		<section>
			<header>
				<h1><span>3</span>背景定位</h1>
			</header>
			<div class="entry backgroundposition">
				<p>背景知识</p>
				<p>background-position</p>
				<p>指定背景图片距离任意角的偏移量</p>
				<p>background-position: right 20px bottom 10px;</p>
				<p>有些浏览器并兼容上述样式，应该提供一个回退方案,如：</p>
				<p>background:url(code-pirate.svg) no-repeat bttom right #58a;background-position: right 20px bottom 10px;</p>
				<p>如：background-position: top left;这个左上角到底是哪个，可以使用bakcground-origin来设置</p>
				<p>background-origin:border-box/pading-box/content-box</p>
				<img src="./css/img/background-origin-box.png" />
			</div>
		</section>

		<section>
			<header>
				<h1><span>4</span>边框内圆角</h1>
			</header>
			<div class="entry boxshadowoutline">
				<p>背景知识</p>
				<p>box-shadow,outline,"多重边框"</p>
				<p>box-shadow: 0 0 0 .8rem #6D5E58;</p>
				<p>box-shadow的宽度要比(根号2-1)*圆角半径长</p>
			</div>
		</section>

		<section>
			<header>
				<h1><span>5</span>条纹背景</h1>
			</header>
			<div class="entry  stripebackground" id="stripes">
				<p>背景知识</p>
				<p>CSS线性渐变，background-size</p>
				<p>background:linear-gradient(#fb3,#58a);</p>
				<p>background:linear-gradient(#fb3 20%, #58a 80%);便是容器顶部的20%区域被填充为#fb3实色，而底部20%区域被填充为#58a实色，真正的渐变只出现在容日中间60%的高度区域中，如果把两个色标继续拉近，那真正的渐变区域就变得更窄了</p>
				<p>当前背景是两个色标重合在一起，如果把第二个色标的位置设置为0，那它的位置就总是会被浏览器调整为前一个色标的位置值。也可以创建不全等的条纹：background: linear-gradient( #fb3 30%,#58a 30% );</p>
				<p class="stripeP stripedir">click me把条纹方向向左</p>
				<p>background: linear-gradient( to right,#fb3 50%,#58a 50%);</p>
				<p class="stripeP  stripes">click me把条纹生成三种颜色的条纹</p>
				<p>background: linear-gradient( #fb3 33.30%,#58a 0,#58a 66.6%,yellowgreen 0);</p>
				<p class="stripeP  stripetilt">click me条纹45deg</p>
				<p>background: linear-gradient( 45deg, #fb3 25%,#58a 0,#58a 50%,#fb3  0, #fb3 75%,#58a 0);</p>
				<p class="stripeP stripetilt">click me条纹60deg</p>
				<p>background: repeating-linear-gradient( 45deg, #fb3,#fb3 15px,#58a 0,#58a 30px );</p>
				<p class="stripeP stripeover">click me网格条纹</p>
				<p>background-image:linear-gradient( 90deg, rgba(200,0,0,.5) 50%, transparent 0 ),linear-gradient( rgba(200,0,0,.5) 50%, transparent 0 );</p>
				<p class="stripeP stripetan">click me重复圆圈背景</p>
				<p>radial-gradient( tan 30%, transparent 0 ),radial-gradient(tan 30%, transparent 0);</p>
			</div>
		</section>

		<section>
			<header>
				<h1><span></span></h1>
			</header>
		</section>
	</article>
	<script type="text/javascript">
		//事件委托
		var stripedir = stripes = stripetilt45  = stripetilt60 = stripeoverlap = stripetanover = true;
		var stripes = {
			stripedir: true,
			stripes: true,
			stripetilt45: true,
			stripetilt60: true,
			stripeoverlap: true,
			stripetanover: true
		}
		document.getElementById( "stripes" ).addEventListener( "click", function( event ){
			switch (event.target) {
				case document.getElementsByClassName( "stripedir" )[0] : stripefunc( "stripedir", "rifgtstripebackground" );break;
				case document.getElementsByClassName( "stripes" )[0] : stripefunc( "stripes", "threestripebackground" );break;
				case document.getElementsByClassName( "stripetilt" )[0] : stripefunc( "stripetilt45", "tilt45stripebackground" );break;
				case document.getElementsByClassName( "stripetilt" )[1] : stripefunc( "stripetilt60", "tilt60stripebackground" );break;
				case document.getElementsByClassName( "stripeover" )[0] : stripefunc( "stripeoverlap", "stripeoverlap" );break;
				case document.getElementsByClassName( "stripetan" )[0] : stripefunc( "stripetanover", "stripetanover" );break;
				default : break;
			}
		} );

		function stripefunc( key, className ){
			stripes[key] ? (function(){
				var div = document.getElementsByClassName( "stripebackground" )[0].classList;
				div.remove( "stripebackground" );
				div.add( className );
				stripes[key] = false;
			})() : (function(){
				var div = document.getElementsByClassName( className )[0].classList;
				div.remove(  className );
				div.add( "stripebackground" );
				stripes[key] = true;
			})();
		}
	</script>
</body>
</html>